#!/usr/bin/env bash
# Show git status for all repos in a directory
# Usage: gitstatus           # Check subdirectories of current dir
#        gitstatus ~/code    # Check subdirectories of ~/code

set -euo pipefail

DIR="${1:-.}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

check_repo() {
    local repo="$1"
    local name=$(basename "$repo")

    cd "$repo" 2>/dev/null || return

    # Check if it's a git repo
    if ! git rev-parse --git-dir &>/dev/null; then
        return
    fi

    # Get status info
    local branch=$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
    local status=$(git status --porcelain 2>/dev/null)
    local ahead_behind=$(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null || echo "0 0")
    local behind=$(echo "$ahead_behind" | awk '{print $1}')
    local ahead=$(echo "$ahead_behind" | awk '{print $2}')

    # Build status string
    local state=""
    [[ -n "$status" ]] && state+="${YELLOW}*${NC}"  # Dirty
    [[ "$ahead" -gt 0 ]] && state+="${GREEN}+${ahead}${NC}"  # Ahead
    [[ "$behind" -gt 0 ]] && state+="${RED}-${behind}${NC}"  # Behind
    [[ -z "$state" ]] && state="${GREEN}ok${NC}"

    printf "  ${BLUE}%-20s${NC} %-15s %s\n" "$name" "($branch)" "$state"
}

echo -e "${BLUE}Git repositories in ${DIR}:${NC}"
echo ""

# Find git repos (max depth 2)
found=0
for d in "$DIR"/*/.git "$DIR"/*/*/.git; do
    if [[ -d "$d" ]]; then
        repo=$(dirname "$d")
        check_repo "$repo"
        found=1
    fi
done

if [[ $found -eq 0 ]]; then
    echo "  No git repositories found"
fi

echo ""
echo -e "Legend: ${YELLOW}*${NC}=dirty ${GREEN}+N${NC}=ahead ${RED}-N${NC}=behind ${GREEN}ok${NC}=clean"
